#pragma once

#define MAX_LEN 256 // Максимальная длина пути или имени

typedef struct SplittedPattern {
    char* search_pattern; // Шаблон для поиска
    char* rename_pattern; // Шаблон для переименовывания
} SplittedPattern;

// Принимает:   string - любая строка
//
// функция пропускает все символы "пробел"
//
// Возвращает:  указатель на первый символ после пробелов
char* skip_space(char* string);

// Принимает:   input_string - строка с шаблонами
//
// Проверяет наличие запрещённых символов
//
// Возвращает:  0, если нет запрещённых символов
//              -1, если есть запрещённые символы
int check_wrong_symbols(char* input_string);

// Принимает:   input_string - строка с шаблонами
//
// Проверяет те строки с шаблонами, в которых может
// неправильно использоваться двоеточие, например:
//    Двоеточие в самом начале строки
//    Два символа двоеточия в строке
//    Двоеточие отсутствует
//
// Возвращает:  0, если нет ошибок
//              -1, если есть ошибки
int check_colon(char* input_string);

// Принимает:   pattern - отдельный шаблон
//
// Проверяет шаблон на наличие ошибок, связанных с
// использованием звезды и смещает указатель
// input_string на следующий за звездой символ
// Ошибки, связанные со звездой:
//   Рядом со звездой стоит символ вопроса
//   Ещё одна звезда используется прежде, чем точка
//
// Возвращает:  0, если нет ошибок
//              -1, если есть ошибки
int check_star(char** pattern);

// Принимает:   pattern - отдельный шаблон
//
// Проверяет шаблон на наличие ошибок, связанных с
// использованием вопроса
// Ошибки, связанные с вопросом:
//   Рядом с вопросом стоит символ звезды
//
// Возвращает:  0, если нет ошибок
//              -1, если есть ошибки
int check_quest(char* pattern);

// Принимает:   pattern - отдельный шаблон
//
// Проверяет шаблон на наличие ошибок, связанных с
// использованием пробела. Если появился пробел, и
// после пробела используются ещё какие-то символы,
// то шаблон введён некорректно. Пробелы могут быть
// только в начале строки с шаблонами, между
// шаблонами и двоеточием и в конце строки
//
// Возвращает:  0, если нет ошибок
//              -1, если есть ошибки
int check_space(char* pattern);

// Принимает:   tokens - массив указателей
//              str - строка, которую нужно разделить
//              delim - символ-разделитель
//
// Функция записывает в массив части строки.
// Предполагается, что будет записана строка,
// разделённая на две части
//
// Возвращает:  0, если запись прошла успешно
//              -1, получить две части не удалось
int get_tokens(char** tokens, char* str, char* delim);

// Принимает:   pattern - отдельный шаблон
//
// Функция посимвольно проверяет весь шаблон на
// наличие различных ошибок в его написании. Для
// проверки используются функции, описанные выше
//
// Возвращает:  0, если шаблон корректный
//              -1, если в шаблоне есть ошибка
int check_pattern(char* pattern);

// Принимает:   input_string - строка с шаблонами
//
// Функция проверяет сразу всю строку на корректность
// ввода. Сначала проверяются те ошибки, которые можно
// проверить, не разделяя строку. После этого строка
// делится на два шаблона и шаблоны проверяются по
// отдельности
//
// Возвращает:  0, если строка введена верно
//              -1, если в строке есть ошибка
int check_input_string(char* input_string);

// Принимает:   inp_str - строка с шаблонами
//              pattern - отдельный шаблон
//
// Функция считывает ближайший шаблон из строки
// inp_str и записывает его в строку pattern.
// Предполагается, что первый символ inp_str -
// это начало шаблона
//
// Возвращает:  указатель на первый символ после
// шаблона в строке inp_str
char* get_pattern(char* inp_str, char* pattern);

// Принимает:   inp_str - строка с шаблонами
//
// Функция смещает указатель inp_str на первый символ
// ближайшего шаблона. Предполагается, что изначально
// inp_str указывает на пространство вне шаблона.
//
// Возвращает:  указатель на первый символ шаблона
char* to_rename_pattern(char* inp_str);

// Принимает:   input_string - строка с шаблонами
//              patterns - указатель на структуру
//              с шаблонами
//
// Функция делит строку с шаблонами на два отдельных
// шаблона без лишних пробелов и двоеточий и записывает
// их в поля структуры
void split_input_string(char* input_string, SplittedPattern* patterns);

// Принимает:   input_string - строка с шаблонами
//              patterns - указатель на структуру
//              с шаблонами
//
// Функция проверяет корректность введённой строки,
// выделяет память под поля структуры, если строка
// введена корректно и делит строку на шаблоны,
// записывая их в поля структуры
//
// Возвращает:  0, если входящая строка корректная
//              -1, если в строке была ошибка
int get_patterns(char* input_string, SplittedPattern* patterns);

// Принимает:   patterns - указатель на список структур с шаблонами
//              input_string - строка с шаблонами
//              exit_code - код выхода из функции проверки строки
//
// Функция выделяет память под структуру с шаблонами и пробует разделить
// шаблоны и записать их в поля структуры. Если операция проходит успешно
// то шаблоны добавляются в список, в противном случае выделенная память
// освобождается
//
// Возвращает:  указатель на список patterns
GList* add_patterns(GList* patterns, char* input_string, int* exit_code);

// Принимает:   patterns - указатель на структуру с шаблонами
//
// Функция освобождает память, выделенную под поля структуры
// и под саму структуру
void free_SplittedPattern(void* patterns);